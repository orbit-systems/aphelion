#ifndef LUNA_LEX_H
#define LUNA_LEX_H

#include "common/type.h"

typedef enum : u8 {
    TOK_INVALID = 0,

    TOK_NEWLINE,

    TOK_IDENT,  /// Identifier of any kind.
    TOK_STRING, /// String literal

    TOK_INST,     /// Instruction name
    TOK_GPR,      /// General-purpose register name
    TOK_CTRL_REG, /// Control register name

    TOK_COMMA,
    TOK_COLON,

    TOK_PLUS,
    TOK_MINUS,
    TOK_MUL,
    TOK_DIV,
    TOK_MOD,
    TOK_AND,
    TOK_OR,
    TOK_TILDE,

    TOK_OPEN_PAREN,
    TOK_CLOSE_PAREN,
    TOK_OPEN_BRACKET,
    TOK_CLOSE_BRACKET,
    TOK_OPEN_BRACE,
    TOK_CLOSE_BRACE,

    // content inclusion
    TOK_KW_INCLUDE,
    TOK_KW_FORCEINCLUDE,

    // declarations
    TOK_KW_SECTION,
    TOK_KW_GROUP,
    TOK_KW_SYMBOL,
    TOK_KW_EXTERN,
    TOK_KW_DEFINE,

    // symbol modifiers
    TOK_KW_ENTRY,

    // symbol binding
    TOK_KW_GLOBAL,
    TOK_KW_LOCAL,
    TOK_KW_WEAK,

    // data modifiers
    TOK_KW_REPEAT,
    TOK_KW_UNALIGNED,

    // data
    TOK_KW_ALIGN,
    TOK_KW_LOC,
    TOK_KW_ZERO,
    TOK_KW_BYTE,
    TOK_KW_QWORD,
    TOK_KW_HWORD,
    TOK_KW_WORD,
    TOK_KW_STRING,

    // section flags
    TOK_KW_UNMAPPED,
    TOK_KW_WRITABLE,
    TOK_KW_EXECUTABLE,
    TOK_KW_THREADLOCAL,
    TOK_KW_BLANK,
    TOK_KW_PINNED,
    TOK_KW_COMMON,
    TOK_KW_NONVOLATILE,
    TOK_KW_CONCATENATE,
} LunaTokenKind;

#ifdef HOST_POINTER_48_BITS
    /// A token of text from a file.
    /// Note that length is not stored, as it can be cheaply recalculated if needed.
    /// It is often not needed, as the token kind is enough for most cases.
    typedef struct LunaToken {
        /// The token's kind. (LunaTokenKind)
        u64 kind : 8;
        /// Subtype, if applicable. Opcode, GPR, control register, etc.
        u64 subtype : 8;
        /// First 48 bits of a pointer to the first character in the text.
        i64 raw : 48;
    } LunaToken;
#else
    /// A token of text from a file.
    typedef struct LunaToken {
        /// The token's kind.
        LunaTokenKind kind;
        /// Whether the token is a 'fake' token generated by the lexer,
        /// e.g. unmatched closing delimiters that the compiler inserted
        /// to help the parser recover from errors.
        u8 subtype;
        /// First 48 bits of a pointer to the first character in the text.
        /// \note Owned by the `SourceFile`, which is owned by the `MarsCompiler` object.
        char* raw;
    } LunaToken;
#endif

/// Return the pointer to the character a token `t` starts at.
static inline const char* token_start(LunaToken t) {
    return (const char*)(isize)t.raw;
}

/// Mnemonic/name for an opcode. If an opcode is not present, gives `nullptr`.
extern const char* const op_mnemonic[256];

#endif // LUNA_LEX_H
