APH3 | APHELION VERSION 3.0

64-bit registers
32-bit address space

registers
    rz - always 0
    r[a-k] - general purpose
    pc - program counter        * note: only first 32 bits are used, last 32 bits are ignored (for now)
    sp - stack pointer
    fp - frame pointer
    st - status register, contains bit flags

    pc, sp, fp, and st are all read-only unless in real mode.

instructions

    nop                         |   no operation

    ldi     rd, imm16           |   rd[0-15] = imm16      (sign ext)
    ldiz    rd, imm16           |   rd[0-15] = imm16
    ldui    rd, imm16           |   rd[16-31] = imm16     (sign ext)
    lduiz   rd, imm16           |   rd[16-31] = imm16
    ldni    rd, imm16           |   rd[32-47] = imm16     (sign ext)
    ldnui   rd, imm16           |   rd[48-63] = imm16 
    ldw     rd, r1, imm16       |   rd = mem[[r1] + imm16] (word)
    ldh     rd, r1, imm16       |   rd = mem[[r1] + imm16] (hword)  (sign ext)
    ldhz    rd, r1, imm16       |   rd = mem[[r1] + imm16] (hword)  (zero ext)
    ldq     rd, r1, imm16       |   rd = mem[[r1] + imm16] (qword)  (sign ext)
    ldqz    rd, r1, imm16       |   rd = mem[[r1] + imm16] (qword)  (zero ext)
    ldb     rd, r1, imm16       |   rd = mem[[r1] + imm16] (byte)   (sign ext)
    ldbz    rd, r1, imm16       |   rd = mem[[r1] + imm16] (byte)   (zero ext)
    str     r1, rd, imm16       |   mem[[rd] + imm16] = r1 (word)
    strh    r1, rd, imm16       |   mem[[rd] + imm16] = r1 (hword)
    strq    r1, rd, imm16       |   mem[[rd] + imm16] = r1 (qword)
    strb    r1, rd, imm16       |   mem[[rd] + imm16] = r1 (byte)

    add     rd, r1, r2          |   rd = r1 + r2
    add     rd, r1, imm16       |   rd = r1 + imm16 (sign ext)
    addc    rd, r1, r2          |   rd = r1 + r2+ carry
    addc    rd, r1, imm16       |   rd = r1 + imm16 (sign ext) + carry
    sub     rd, r1, r2          |   rd = r1 - r2
    sub     rd, r1, imm16       |   rd = r1 - imm16 (sign ext)
    subb    rd, r1, r2          |   rd = r1 - r2 - borrow
    subb    rd, r1, imm16       |   rd = r1 - imm16 (sign ext) - borrow
    mul     rd, r1, r2          |   rd = r1 * r2
    mul     rd, r1, imm16       |   rd = r1 * imm16 (sign ext)
    div     rd, rm, r1, r2      |   rd = r1 // r2, rm = r1 % r2
    div     rd, rm, r1, imm16   |   rd = r1 // imm16 (sign ext), rm = r1 % imm16 (sign ext)

    and     rd, r1, r2          |   reg = reg & reg
    and     rd, r1, imm16       |   reg = reg & imm16 (zero ext)
    or      rd, r1, r2          |   reg = reg | reg
    or      rd, r1, imm16       |   reg = reg | imm16 (zero ext)
    nor     rd, r1, r2          |   reg = !(reg | reg)
    nor     rd, r1, imm16       |   reg = !(reg | imm) (zero ext)
    xor     rd, r1, r2          |   reg = reg ^ reg
    xor     rd, r1, imm16       |   reg = reg ^ imm16 (zero ext)

    shl     rd, r1, r2          |   reg = reg << reg
    shl     rd, r1, imm16       |   reg = reg << imm (zero ext)
    asr     rd, r1, r2          |   reg = reg >> reg
    asr     rd, r1, imm16       |   reg = reg >> imm (zero ext)
    lsr     rd, r1, r2          |   reg = reg >> reg (logical)
    lsr     rd, r1, imm16       |   reg = reg >> imm (logical) (zero ext)

    push    r1                  |   push value in register
    push    imm16               |   push immediate (sign ext)
    pushz   imm16               |   push immediate (zero ext)
    pushq   imm16               |   push immediate (qword)
    pop     rd                  |   pop to register

    jal     r1, imm16           |   pc = r1 + (imm16*4) (sign ext), push return location to stack
    jalr    r1, imm16, r2       |   pc = r1 + (imm16*4) (sign ext), send return location to r2
    ret                         |   pc = [val popped of stack]
    retr    rd                  |   pc = rd
    
    brnc    imm16, r1           |   pc += (imm16*4) (sign ext), send return location to r1      * work this out
    brnc    imm16               |   pc += (imm16*4) (sign ext), push return location to stack   * work this out

    enter   enter stack frame
    leave   leave stack frame

    int     trigger interrupt
    virt    enter virtual mode
    call    trigger interrupt from kernel-defined interrupt set (enters user mode)

extension ideas for later
    floating point
    BCD

shorthand
    word -> 64 bit
    hword -> 32 bit         (half word)
    qword -> 16 bit         (quarter word)