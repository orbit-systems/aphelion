APHELION VERSION 0.1

64-bit registers
32-bit address space

registers
    rz - always 0
    r[a-k] - general purpose
    pc - program counter        * note: only first 32 bits are used, last 32 bits are ignored (for now)
    sp - stack pointer
    fp - frame pointer
    st - status register, contains bit flags

    pc, sp, fp, and st are all read-only unless in real mode.

instructions

    nop                         |   no operation

    ldi     rd, imm16           |   rd[0-15] = imm16      (sign ext)
    ldiz    rd, imm16           |   rd[0-15] = imm16
    ldui    rd, imm16           |   rd[16-31] = imm16     (sign ext)
    lduiz   rd, imm16           |   rd[16-31] = imm16
    ldni    rd, imm16           |   rd[32-47] = imm16     (sign ext)
    ldnui   rd, imm16           |   rd[48-63] = imm16 
    ldw     rd, r1, imm16       |   rd = mem[r1 + imm16] (word)
    ldh     rd, r1, imm16       |   rd = mem[r1 + imm16] (hword)  (sign ext)
    ldhz    rd, r1, imm16       |   rd = mem[r1 + imm16] (hword)  (zero ext)
    ldq     rd, r1, imm16       |   rd = mem[r1 + imm16] (qword)  (sign ext)
    ldqz    rd, r1, imm16       |   rd = mem[r1 + imm16] (qword)  (zero ext)
    ldb     rd, r1, imm16       |   rd = mem[r1 + imm16] (byte)   (sign ext)
    ldbz    rd, r1, imm16       |   rd = mem[r1 + imm16] (byte)   (zero ext)
    str     r1, rd, imm16       |   mem[rd + imm16] = r1 (word)
    strh    r1, rd, imm16       |   mem[rd + imm16] = r1 (hword)
    strq    r1, rd, imm16       |   mem[rd + imm16] = r1 (qword)
    strb    r1, rd, imm16       |   mem[rd + imm16] = r1 (byte)

    add     rd, r1, r2          |   rd = r1 + r2
    add     rd, r1, imm16       |   rd = r1 + imm16 (sign ext)
    addc    rd, r1, r2          |   rd = r1 + r2+ carry
    addc    rd, r1, imm16       |   rd = r1 + imm16 (sign ext) + carry
    sub     rd, r1, r2          |   rd = r1 - r2
    sub     rd, r1, imm16       |   rd = r1 - imm16 (sign ext)
    subb    rd, r1, r2          |   rd = r1 - r2 - borrow
    subb    rd, r1, imm16       |   rd = r1 - imm16 (sign ext) - borrow
    mul     rd, r1, r2          |   rd = r1 * r2
    mul     rd, r1, imm16       |   rd = r1 * imm16 (sign ext)
    div     rd, rm, r1, r2      |   rd = r1 // r2, rm = r1 % r2
    div     rd, rm, r1, imm16   |   rd = r1 // imm16 (sign ext), rm = r1 % imm16 (sign ext)

    and     rd, r1, r2          |   rd = r1 & r2
    and     rd, r1, imm16       |   rd = r1 & imm16 (zero ext)
    or      rd, r1, r2          |   rd = r1 | r2
    or      rd, r1, imm16       |   rd = r1 | imm16 (zero ext)
    nor     rd, r1, r2          |   rd = !(r1 | r2)
    nor     rd, r1, imm16       |   rd = !(r1 | imm) (zero ext)
    xor     rd, r1, r2          |   rd = r1 ^ r2
    xor     rd, r1, imm16       |   rd = r1 ^ imm16 (zero ext)

    shl     rd, r1, r2          |   rd = r1 << r2
    shl     rd, r1, imm16       |   rd = r1 << imm (zero ext)
    asr     rd, r1, r2          |   rd = r1 >> r2
    asr     rd, r1, imm16       |   rd = r1 >> imm (zero ext)
    lsr     rd, r1, r2          |   rd = r1 >> r2 (logical)
    lsr     rd, r1, imm16       |   rd = r1 >> imm (logical) (zero ext)

    push    r1                  |   mem[sp] = r1, sp -= 4 (push value in register to stack)
    push    imm16               |   mem[sp] = imm16(sign ext), sp -= 4  (push immediate to stack)
    pushz   imm16               |   mem[sp] = imm16(zero ext), sp -= 4  (push immediate to stack)
    pushq   imm16               |   mem[sp] = r1, sp -= 4 (push immediate qword to stack)
    pop     rd                  |   rd = mem[sp], sp -= 4 pop to register

    jal     r1, imm16           |   pc = r1 + (imm16*4) (sign ext), push return location to stack
    jalr    r1, imm16, rd       |   pc = r1 + (imm16*4) (sign ext), send return location to rd
    ret                         |   pc = mem[sp], sp -= 4
    retr    rd                  |   pc = rd
    
    bcc     imm20               |   pc += (imm20*4) (sign ext) if condition is met

    enter   enter stack frame
    leave   leave stack frame

    int     trigger interrupt
    virt    enter virtual mode
    ucall   trigger interrupt from kernel-defined interrupt set (enters user mode)

extension ideas for later
    floating point
    BCD

shorthand
    word -> 64 bit
    hword -> 32 bit         (half word)
    qword -> 16 bit         (quarter word)