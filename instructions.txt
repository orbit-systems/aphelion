nop                         |   no operation

li      rd, imm16           |   rd[0-15] = imm16
lis     rd, imm16           |   rd[0-15] = imm16    (se)
lui     rd, imm16           |   rd[16-31] = imm16
luis    rd, imm16           |   rd[16-31] = imm16   (se)
lni     rd, imm16           |   rd[32-47] = imm16
lnis    rd, imm16           |   rd[32-47] = imm16   (se)
lnui    rd, imm16           |   rd[48-63] = imm16
lnui    rd, imm16           |   rd[48-63] = imm16   (se)
lw      rd, r1, imm16       |   rd = mem[r1 + imm16] (word)
lbs     rd, r1, imm16       |   rd = mem[r1 + imm16] (byte)   (se)
lb      rd, r1, imm16       |   rd[0-7] = mem[r1 + imm16] (byte)
st      rs, rd, imm16       |   mem[rd + imm16] = rs (word) (l. end)
stb     r1, rd, imm16       |   mem[rd + imm16] = r1 (byte)
cpy     rd, r1              |   rd = r1             (encoded as add rd, r1, 0)
swp     r1, r2              |   (r1, r2) = (r2, r1)

add     rd, r1, r2          |   rd = r1 + r2
add     rd, r1, imm16       |   rd = r1 + imm16 (se)
adc     rd, r1, r2          |   rd = r1 + r2 + carry
adc     rd, r1, imm16       |   rd = r1 + imm16 (se) + carry
sub     rd, r1, r2          |   rd = r1 - r2
sub     rd, r1, imm16       |   rd = r1 - imm16 (se)
sbb     rd, r1, r2          |   rd = r1 - r2 - borrow
sbb     rd, r1, imm16       |   rd = r1 - imm16 (se) - borrow
mul     rd, r1, r2          |   rd = r1 * r2
mul     rd, r1, imm16       |   rd = r1 * imm16 (se)
div     rd, r1, r2          |   rd = r1 / r2
div     rd, r1, imm16       |   rd = r1 / imm16 (se)
mod     rd, r1, r2          |   rd = r1 % r2
mod     rd, r1, imm16       |   rd = r1 % imm16 (se)

and     rd, r1, r2          |   rd = r1 & r2
and     rd, r1, imm16       |   rd = r1 & imm16(ze)
or      rd, r1, r2          |   rd = r1 | r2
or      rd, r1, imm16       |   rd = r1 | imm16(ze)
nor     rd, r1, r2          |   rd = !(r1 | r2)
nor     rd, r1, imm16       |   rd = !(r1 | imm16(ze))
xor     rd, r1, r2          |   rd = r1 ^ r2
xor     rd, r1, imm16       |   rd = r1 ^ imm16(ze)
shl     rd, r1, r2          |   rd = r1 << r2
shl     rd, r1, imm16       |   rd = r1 << imm16(unsigned)
asr     rd, r1, r2          |   rd = r1 >> r2
asr     rd, r1, imm16       |   rd = r1 >> imm16(unsigned)
lsr     rd, r1, r2          |   rd = r1 >> r2
lsr     rd, r1, imm16       |   rd = r1 >> imm16(unsigned)

push    r1                  |   sp -= 8, mem[sp] = r1   (l. end)
push    imm16               |   sp -= 8, mem[sp] = imm16(se)  (l. end)
pushz   imm16               |   sp -= 8, mem[sp] = imm16(ze)  (l. end)
pushq   imm16               |   sp -= 2, mem[sp] = imm16    (l. end)        * for constructing 64-bit immediate push
pop     rd                  |   rd = mem[sp], sp += 8

jal     r1, imm16           |   pc = r1 + imm16*4 (se), push (pc+4)
jalr    r1, imm16, rd       |   pc = r1 + imm16*4 (se), rd = (pc+4)
ret                         |   pc = mem[sp], sp -= 4
retr    rd                  |   pc = rd
bcc     imm20               |   pc += imm20*4 (se) if condition is met

enter                       |   push fp, fp = sp    (enter stack frame)
leave                       |   sp = fp, pop fp     (leave stack frame)

int     imm16               |   trigger interrupt
virt                        |   enter virtual mode
rcall   imm16               |   trigger interrupt from real-defined interrupt table (enters real mode)




notes
    word -> 64 bit

    (se) -> sign extend (set lower bits to zero)
    (ze) -> zero extend (set lower bits to zero)

    // -> considering deletion

extension ideas for later
    floating point
    BCD